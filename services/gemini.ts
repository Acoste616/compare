import { AnalysisState, Message, JourneyStage, RagNugget, GoldenStandard } from "../types";

// --- SERVICE ---

export class AIService {
  private backendUrl: string;

  constructor() {
    // Point to the Python Backend - use environment variable or fallback
    this.backendUrl = (import.meta as any).env?.VITE_BACKEND_URL || "http://localhost:8000";
  }

  // === LOCAL RETRIEVAL ENGINE (RAG) ===
  // Kept for client-side optimistic updates or fallback, 
  // but ideally this should also be moved to backend if we want full RAG there.
  // For now, we'll keep the simple keyword matcher for immediate UI feedback if needed,
  // but the ACTUAL response comes from the backend.
  findRelevantContext(query: string, nuggets: RagNugget[], standards: GoldenStandard[]): string {
    // This logic is now largely handled by the backend's RAG engine.
    // We keep it here just in case we want to display "Related Nuggets" in the UI immediately.
    return "";
  }

  // === FAST PATH ===
  async generateFastResponse(
    history: Message[],
    ragContext: string,
    journeyStage: string,
    language: string = 'PL',
    sessionId: string = 'default-session'
  ): Promise<Partial<Message>> {
    try {
      const lastUserMessage = history[history.length - 1];
      if (lastUserMessage.role !== 'user') {
        throw new Error("Last message must be from user");
      }

      const payload = {
        session_id: sessionId,
        user_input: lastUserMessage.content,
        journey_stage: journeyStage,
        language: language,
        history: history.map(msg => ({ role: msg.role, content: msg.content }))
      };

      const response = await fetch(`${this.backendUrl}/api/chat`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
        signal: AbortSignal.timeout(45000) // 45 second timeout - allows for RAG cold start (16-20s) + buffer
      });

      if (!response.ok) {
        throw new Error(`Backend error: ${response.statusText}`);
      }

      const data = await response.json();

      return {
        content: data.response,
        confidence: data.confidence,
        confidenceReason: "Generated by ULTRA Backend",
        clientStyle: "Analyzed by AI Core",
        contextNeeds: data.questions || [],
        suggestedActions: data.suggested_actions || [],
      };

    } catch (error) {
      console.error("Fast Path Error:", error);
      return {
        content: "System Notification: Unable to connect to ULTRA Backend. Please ensure the Python server is running on port 8000.",
        confidence: 0,
        clientStyle: "Unknown"
      };
    }
  }

  // === SLOW PATH ===
  // The backend now handles this via WebSockets or Background Tasks.
  // This method might be deprecated or used to explicitly trigger analysis if needed.
  async generateSlowAnalysis(history: Message[], currentStage: JourneyStage, language: string = 'PL'): Promise<Partial<AnalysisState>> {
    // Analysis is now pushed via WebSocket from the backend.
    // We can return empty here as the store will be updated via WS.
    return {};
  }

  // === FEEDBACK SYSTEM ===
  async sendFeedback(
    sessionId: string,
    userInput: string,
    aiResponse: string,
    rating: 'positive' | 'negative',
    feedbackText: string = ''
  ): Promise<{ status: string; feedback_id?: number } | null> {
    try {
      const payload = {
        session_id: sessionId,
        user_input: userInput,
        ai_response: aiResponse,
        rating: rating,
        feedback_text: feedbackText
      };

      const response = await fetch(`${this.backendUrl}/api/feedback`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        console.error(`Feedback error: ${response.statusText}`);
        return null;
      }

      const data = await response.json();
      console.log('[FEEDBACK] Saved successfully:', data);
      return data;

    } catch (error) {
      console.error('[FEEDBACK] Error sending feedback:', error);
      // Don't throw - feedback shouldn't break the app
      return null;
    }
  }
}